{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my github ~ \u00b6 \u200b Nama : Ahmad Faisol Wahyudi \u200b NIM : 180411100103 \u200b Kelas : Komputasi Numerik 4A \u200b Prodi : Teknik Informatika \u200b Dosen : Mula'ab, S.Si, M.Kom","title":"Home"},{"location":"#welcome-to-my-github","text":"\u200b Nama : Ahmad Faisol Wahyudi \u200b NIM : 180411100103 \u200b Kelas : Komputasi Numerik 4A \u200b Prodi : Teknik Informatika \u200b Dosen : Mula'ab, S.Si, M.Kom","title":"Welcome to my github ~"},{"location":"Installation/Install MKDOCS & Deploy to GITHUB/","text":"Install MKDOCS & Deploy to GITHUB \u00b6 Install python first , make sure it can run pip at cmd . check it with where pip \u00b6 Install Github Desktop , you can download it Download Desktop Github \u00b6 Make sure you are already have an account at github and at least you have 1 repository to deploy your MKDOCS if it ready to post, if you don't have just Read More \u00b6 if you already have an account an repository , make it sure with github desktop that your repository connect with the directory on windows explorer , and make sure that directory have a same place with the directory in the next instruction. ex : if you use tesmkdocs then just use that folder till finish After that follow the instruction : \u00b6 Open CMD and run it as administrator Install MKDOCS with pip and wait it till finish: pip install mkdocs if the cursor show again at cmd it mean that the installation finish Install MKDOCS material. same like before it finish if the cursor show pip : pip install mkdocs-material Next adding on your mkdocs.yml : theme : name : 'material' or you can instant get it with pip , just follow this instruction make a new directory open cmd and make sure cmd already locate at new directory that we was done before just type it pip : git clone https://github.com/squidfunk/mkdocs-material.git if you still confuse , just visit MKDOCS-MATERIAL Edit MKDOCS.yml , change what you wanna change. just open it with notepad and than save it open cmd again and make sure cmd locate at mkdocs.yml that you have edit it before build the mkdocs.yml : mkdocs build at this point , make sure you are already have github account and the repository with github desktop to place mkdocs that already make it before. if don't just read more the last step is to deploy it with mkdocs : mkdocs gh-deploy if finish it will show the url , just copy it and paste at browser","title":"Install MKDOCS"},{"location":"Installation/Install MKDOCS & Deploy to GITHUB/#install-mkdocs-deploy-to-github","text":"","title":"Install MKDOCS &amp; Deploy to GITHUB"},{"location":"Installation/Install MKDOCS & Deploy to GITHUB/#install-python-first-make-sure-it-can-run-pip-at-cmd-check-it-with-where-pip","text":"","title":"Install python first , make sure it can run pip at cmd . check it with where pip"},{"location":"Installation/Install MKDOCS & Deploy to GITHUB/#install-github-desktop-you-can-download-it-download-desktop-github","text":"","title":"Install Github Desktop , you can download it Download Desktop Github"},{"location":"Installation/Install MKDOCS & Deploy to GITHUB/#make-sure-you-are-already-have-an-account-at-github-and-at-least-you-have-1-repository-to-deploy-your-mkdocs-if-it-ready-to-post-if-you-dont-have-just-read-more","text":"if you already have an account an repository , make it sure with github desktop that your repository connect with the directory on windows explorer , and make sure that directory have a same place with the directory in the next instruction. ex : if you use tesmkdocs then just use that folder till finish","title":"Make sure you are already have an account at github and at least you have 1 repository to deploy your MKDOCS if it ready to post, if you don't have just Read More"},{"location":"Installation/Install MKDOCS & Deploy to GITHUB/#after-that-follow-the-instruction","text":"Open CMD and run it as administrator Install MKDOCS with pip and wait it till finish: pip install mkdocs if the cursor show again at cmd it mean that the installation finish Install MKDOCS material. same like before it finish if the cursor show pip : pip install mkdocs-material Next adding on your mkdocs.yml : theme : name : 'material' or you can instant get it with pip , just follow this instruction make a new directory open cmd and make sure cmd already locate at new directory that we was done before just type it pip : git clone https://github.com/squidfunk/mkdocs-material.git if you still confuse , just visit MKDOCS-MATERIAL Edit MKDOCS.yml , change what you wanna change. just open it with notepad and than save it open cmd again and make sure cmd locate at mkdocs.yml that you have edit it before build the mkdocs.yml : mkdocs build at this point , make sure you are already have github account and the repository with github desktop to place mkdocs that already make it before. if don't just read more the last step is to deploy it with mkdocs : mkdocs gh-deploy if finish it will show the url , just copy it and paste at browser","title":"After that follow the instruction :"},{"location":"Installation/Signup GITHUB/","text":"SIGNUP GITHUB \u00b6 Create GITHUB Account \u00b6 visit https://github.com/ click SIGN UP Button at the top right just follow the step and fill the field till you get the confirmation to your email After succesfully confirmation / verified email , you are asked to create a repository just don't create it first just let it be and go to next step :) Create Repository with Github Desktop \u00b6 Download & install it https://desktop.github.com/ After that login with the username and password that you have been create before click file an choose new repository follow the step after that create pull request and after that pull next Just read again the next step to deploy MKDOCS :) click here","title":"SignUP GITHUB"},{"location":"Installation/Signup GITHUB/#signup-github","text":"","title":"SIGNUP GITHUB"},{"location":"Installation/Signup GITHUB/#create-github-account","text":"visit https://github.com/ click SIGN UP Button at the top right just follow the step and fill the field till you get the confirmation to your email After succesfully confirmation / verified email , you are asked to create a repository just don't create it first just let it be and go to next step :)","title":"Create GITHUB Account"},{"location":"Installation/Signup GITHUB/#create-repository-with-github-desktop","text":"Download & install it https://desktop.github.com/ After that login with the username and password that you have been create before click file an choose new repository follow the step after that create pull request and after that pull next Just read again the next step to deploy MKDOCS :) click here","title":"Create Repository with Github Desktop"},{"location":"Komnum/tugas1/","text":"Menghitung error hingga 0.0001 dengan DERET MacLaurin \u00b6 DERET MacLaurin \u00b6 adalah Suatu fungsi yang mirip dengan deret taylor yang menggunakan f(x) yang memiliki turunan f'(x) , f''(x) hingga f faktorial n hanya saja deret ini memiliki nilai a=0 Contoh: f(x) = f(a) + \\frac{f'0}{1!}(x-0) + \\frac{f''0}{2!}(x-0)^{2} + \\frac{f'''0}{3!}(x-0)^{3} + ...... + \\frac{f^{n}0}{n!}(x-0)^{n} f(x) = f(a) + \\frac{f'0}{1!}(x-0) + \\frac{f''0}{2!}(x-0)^{2} + \\frac{f'''0}{3!}(x-0)^{3} + ...... + \\frac{f^{n}0}{n!}(x-0)^{n} Atau bisa dinyatakan dengan: f(x) = \\sum_{i=1}^{\\infty}\\frac{f^{n}(0)}{n!}(x-0)^{n} f(x) = \\sum_{i=1}^{\\infty}\\frac{f^{n}(0)}{n!}(x-0)^{n} Menentukan Rumus e^{2x} e^{2x} \u00b6 Untuk menemukan rumusnya , kita dapat mengimplementasikan rumus diatas ke dalam bilangan yang ingin dicari cukup mengganti nilai ex dengan 0. jika fungsi f(x) = e^x e^x maka f(0) = 1 . Dari nilai diatas kita dapat menyamakan atar ex dengan e^{2x} e^{2x} dimana jika f(x) = e^{2x} e^{2x} maka f(0) = 1 , sedangkan jika diturunkan f'(x) = 2e^{2x} 2e^{2x} maka f(0) = 2 dan jika diturungkan lagi f''(x) = 4e^{2x} 4e^{2x} maka f(0) = 4 maka dari itu kita mendapat rumus untuk bilangan e^{2x} e^{2x} : e^{2x} = \\sum_{n=0}^{\\infty }{\\frac{2^nx^n}{n!}} e^{2x} = \\sum_{n=0}^{\\infty }{\\frac{2^nx^n}{n!}} dapat disimpulkan dari rumus diatas jika kita jabarkan : f(x) = f(0) + \\frac{2}{1!}x + \\frac{4}{2!}x^2 + \\frac{8}{3!}x^3 + .... + \\frac{2^n}{n!}x^n f(x) = f(0) + \\frac{2}{1!}x + \\frac{4}{2!}x^2 + \\frac{8}{3!}x^3 + .... + \\frac{2^n}{n!}x^n Listing Program \u00b6 untuk mengimplementasikan rumus yang sudah di peroleh diatas, berikut Program yang dibuat untuk mencari e^2x e^2x dengan nilai x=4 hingga error mencapai kurang dari 0,001 setidaknya seperti dibawah ini. import math def er ( nilaix , selisih , pertama , kedua , stop , perulangan ): while selisih > stop : f0 = 0 f1 = 0 for i in range ( pertama ): f0 += ( 2 ** i ) * nilaix ** i / math . factorial ( i ) for j in range ( kedua ): f1 += ( 2 ** j ) * nilaix ** j / math . factorial ( j ) selisih = f1 - f0 pertama += 1 kedua += 1 print ( \"Perulangan \" , perulangan , \" = \" , f1 , \" - \" , f0 , \" = \" , selisih ) perulangan += 1 er ( 4 , 1 , 0 , 1 , 0.001 , 1 ) output: Perulangan 1 = 1.0 - 0 = 1.0 Perulangan 2 = 9.0 - 1.0 = 8.0 Perulangan 3 = 41.0 - 9.0 = 32.0 Perulangan 4 = 126.33333333333333 - 41.0 = 85.33333333333333 Perulangan 5 = 297.0 - 126.33333333333333 = 170.66666666666669 Perulangan 6 = 570.0666666666666 - 297.0 = 273.0666666666666 Perulangan 7 = 934.1555555555556 - 570.0666666666666 = 364.08888888888896 Perulangan 8 = 1350.2571428571428 - 934.1555555555556 = 416.1015873015872 Perulangan 9 = 1766.35873015873 - 1350.2571428571428 = 416.1015873015872 Perulangan 10 = 2136.226807760141 - 1766.35873015873 = 369.8680776014112 Perulangan 11 = 2432.12126984127 - 2136.226807760141 = 295.89446208112895 Perulangan 12 = 2647.317242263909 - 2432.12126984127 = 215.195972422639 Perulangan 13 = 2790.781223879002 - 2647.317242263909 = 143.46398161509296 Perulangan 14 = 2879.0667510267513 - 2790.781223879002 = 88.28552714774924 Perulangan 15 = 2929.515623682608 - 2879.0667510267513 = 50.448872655856576 Perulangan 16 = 2956.4216890990647 - 2929.515623682608 = 26.90606541645684 Perulangan 17 = 2969.874721807293 - 2956.4216890990647 = 13.45303270822842 Perulangan 18 = 2976.2055607288125 - 2969.874721807293 = 6.330838921519444 Perulangan 19 = 2979.0192669161543 - 2976.2055607288125 = 2.8137061873417224 Perulangan 20 = 2980.2039853108245 - 2979.0192669161543 = 1.184718394670199 Perulangan 21 = 2980.6778726686925 - 2980.2039853108245 = 0.47388735786807956 Perulangan 22 = 2980.8584011859757 - 2980.6778726686925 = 0.18052851728316455 Perulangan 23 = 2980.924047919533 - 2980.8584011859757 = 0.06564673355751438 Perulangan 24 = 2980.946881565988 - 2980.924047919533 = 0.022833646454728296 Perulangan 25 = 2980.9544927814727 - 2980.946881565988 = 0.0076112154847578495 Perulangan 26 = 2980.9569283704277 - 2980.9544927814727 = 0.0024355889549951826 Perulangan 27 = 2980.957677782414 - 2980.9569283704277 = 0.0007494119863622473","title":"Tugas 1 (Mencari selisih 0,001)"},{"location":"Komnum/tugas1/#menghitung-error-hingga-00001-dengan-deret-maclaurin","text":"","title":"Menghitung error hingga 0.0001 dengan DERET MacLaurin"},{"location":"Komnum/tugas1/#deret-maclaurin","text":"adalah Suatu fungsi yang mirip dengan deret taylor yang menggunakan f(x) yang memiliki turunan f'(x) , f''(x) hingga f faktorial n hanya saja deret ini memiliki nilai a=0 Contoh: f(x) = f(a) + \\frac{f'0}{1!}(x-0) + \\frac{f''0}{2!}(x-0)^{2} + \\frac{f'''0}{3!}(x-0)^{3} + ...... + \\frac{f^{n}0}{n!}(x-0)^{n} f(x) = f(a) + \\frac{f'0}{1!}(x-0) + \\frac{f''0}{2!}(x-0)^{2} + \\frac{f'''0}{3!}(x-0)^{3} + ...... + \\frac{f^{n}0}{n!}(x-0)^{n} Atau bisa dinyatakan dengan: f(x) = \\sum_{i=1}^{\\infty}\\frac{f^{n}(0)}{n!}(x-0)^{n} f(x) = \\sum_{i=1}^{\\infty}\\frac{f^{n}(0)}{n!}(x-0)^{n}","title":"DERET MacLaurin"},{"location":"Komnum/tugas1/#menentukan-rumus-e2xe2x","text":"Untuk menemukan rumusnya , kita dapat mengimplementasikan rumus diatas ke dalam bilangan yang ingin dicari cukup mengganti nilai ex dengan 0. jika fungsi f(x) = e^x e^x maka f(0) = 1 . Dari nilai diatas kita dapat menyamakan atar ex dengan e^{2x} e^{2x} dimana jika f(x) = e^{2x} e^{2x} maka f(0) = 1 , sedangkan jika diturunkan f'(x) = 2e^{2x} 2e^{2x} maka f(0) = 2 dan jika diturungkan lagi f''(x) = 4e^{2x} 4e^{2x} maka f(0) = 4 maka dari itu kita mendapat rumus untuk bilangan e^{2x} e^{2x} : e^{2x} = \\sum_{n=0}^{\\infty }{\\frac{2^nx^n}{n!}} e^{2x} = \\sum_{n=0}^{\\infty }{\\frac{2^nx^n}{n!}} dapat disimpulkan dari rumus diatas jika kita jabarkan : f(x) = f(0) + \\frac{2}{1!}x + \\frac{4}{2!}x^2 + \\frac{8}{3!}x^3 + .... + \\frac{2^n}{n!}x^n f(x) = f(0) + \\frac{2}{1!}x + \\frac{4}{2!}x^2 + \\frac{8}{3!}x^3 + .... + \\frac{2^n}{n!}x^n","title":"Menentukan Rumus e^{2x}e^{2x}"},{"location":"Komnum/tugas1/#listing-program","text":"untuk mengimplementasikan rumus yang sudah di peroleh diatas, berikut Program yang dibuat untuk mencari e^2x e^2x dengan nilai x=4 hingga error mencapai kurang dari 0,001 setidaknya seperti dibawah ini. import math def er ( nilaix , selisih , pertama , kedua , stop , perulangan ): while selisih > stop : f0 = 0 f1 = 0 for i in range ( pertama ): f0 += ( 2 ** i ) * nilaix ** i / math . factorial ( i ) for j in range ( kedua ): f1 += ( 2 ** j ) * nilaix ** j / math . factorial ( j ) selisih = f1 - f0 pertama += 1 kedua += 1 print ( \"Perulangan \" , perulangan , \" = \" , f1 , \" - \" , f0 , \" = \" , selisih ) perulangan += 1 er ( 4 , 1 , 0 , 1 , 0.001 , 1 ) output: Perulangan 1 = 1.0 - 0 = 1.0 Perulangan 2 = 9.0 - 1.0 = 8.0 Perulangan 3 = 41.0 - 9.0 = 32.0 Perulangan 4 = 126.33333333333333 - 41.0 = 85.33333333333333 Perulangan 5 = 297.0 - 126.33333333333333 = 170.66666666666669 Perulangan 6 = 570.0666666666666 - 297.0 = 273.0666666666666 Perulangan 7 = 934.1555555555556 - 570.0666666666666 = 364.08888888888896 Perulangan 8 = 1350.2571428571428 - 934.1555555555556 = 416.1015873015872 Perulangan 9 = 1766.35873015873 - 1350.2571428571428 = 416.1015873015872 Perulangan 10 = 2136.226807760141 - 1766.35873015873 = 369.8680776014112 Perulangan 11 = 2432.12126984127 - 2136.226807760141 = 295.89446208112895 Perulangan 12 = 2647.317242263909 - 2432.12126984127 = 215.195972422639 Perulangan 13 = 2790.781223879002 - 2647.317242263909 = 143.46398161509296 Perulangan 14 = 2879.0667510267513 - 2790.781223879002 = 88.28552714774924 Perulangan 15 = 2929.515623682608 - 2879.0667510267513 = 50.448872655856576 Perulangan 16 = 2956.4216890990647 - 2929.515623682608 = 26.90606541645684 Perulangan 17 = 2969.874721807293 - 2956.4216890990647 = 13.45303270822842 Perulangan 18 = 2976.2055607288125 - 2969.874721807293 = 6.330838921519444 Perulangan 19 = 2979.0192669161543 - 2976.2055607288125 = 2.8137061873417224 Perulangan 20 = 2980.2039853108245 - 2979.0192669161543 = 1.184718394670199 Perulangan 21 = 2980.6778726686925 - 2980.2039853108245 = 0.47388735786807956 Perulangan 22 = 2980.8584011859757 - 2980.6778726686925 = 0.18052851728316455 Perulangan 23 = 2980.924047919533 - 2980.8584011859757 = 0.06564673355751438 Perulangan 24 = 2980.946881565988 - 2980.924047919533 = 0.022833646454728296 Perulangan 25 = 2980.9544927814727 - 2980.946881565988 = 0.0076112154847578495 Perulangan 26 = 2980.9569283704277 - 2980.9544927814727 = 0.0024355889549951826 Perulangan 27 = 2980.957677782414 - 2980.9569283704277 = 0.0007494119863622473","title":"Listing Program"},{"location":"Komnum/tugas2/","text":"Program Newton Raphson pada Fungsi Non Linear \u00b6 Newton Raphson \u00b6 adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga di dapat sebuah rumus : x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4 Implementasi Pemrograman \u00b6 dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Tugas 2 (Membuat Program Newton Rhapson Persamaan Non Linear)"},{"location":"Komnum/tugas2/#program-newton-raphson-pada-fungsi-non-linear","text":"","title":"Program Newton Raphson pada Fungsi Non Linear"},{"location":"Komnum/tugas2/#newton-raphson","text":"adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga di dapat sebuah rumus : x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})}","title":"Newton Raphson"},{"location":"Komnum/tugas2/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson"},{"location":"Komnum/tugas2/#implementasi-pemrograman","text":"dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Implementasi Pemrograman"},{"location":"Komnum/tugas3/","text":"Sistem Persamaan Linear (Pendekatan Numerik) \u00b6 Persamaan linear dalam n variabel x_1,x_2, . . . ,x_n x_1,x_2, . . . ,x_n adalah suatu persamaan yang bisa disajikan dalam bentuk : $$ a_{11}x_1+a_{12}x_2+ . . . +a_{1n}x_n = b_1 $$ a_{21}x_2+a_{22}x_2+ . . . +a_{2n}+x_n = b_2 a_{21}x_2+a_{22}x_2+ . . . +a_{2n}+x_n = b_2 \\vdots \\vdots $$ a_{m1}x_1+a_{m2}x_2+ . . . +a_{mn}x_n = b_m $$ dimana a_1,a_2, . . . , a_n a_1,a_2, . . . , a_n dan b b konstanta real. Variabel-variabel dalam suatu persamaan linear kadang disebut variabel bebas . Sebuah sistem m persamaan dalam n variabel dapat disingkat hanya menuliskan angka dalam bentuk segiempat. Dalam bentuk maktriks , SPL dapat ditulis dengan A**x* = b* , dimana : \\begin{bmatrix} a_{11} & a_{12} & ... & a_{1n}\\\\ a_{21} & a_{22} & ... & a_{2n}\\\\ \\vdots & \\vdots & & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn}\\\\ \\end{bmatrix}, x= \\begin{bmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{bmatrix}, b= \\begin{bmatrix} b_1\\\\ b_2\\\\ \\vdots\\\\ b_n \\end{bmatrix} \\begin{bmatrix} a_{11} & a_{12} & ... & a_{1n}\\\\ a_{21} & a_{22} & ... & a_{2n}\\\\ \\vdots & \\vdots & & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn}\\\\ \\end{bmatrix}, x= \\begin{bmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{bmatrix}, b= \\begin{bmatrix} b_1\\\\ b_2\\\\ \\vdots\\\\ b_n \\end{bmatrix} Metode Iterasi Jacobi \u00b6 Metode iterasi Jacobi merupakan salah satu metode tak langsung, yang bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier yang proporsi koefisien nol nya besar. Jika diubah dari persamaan linier, maka akan menjadi : A_x = b A_x = b Kemudian diketahui bahwa A = D + (L + U), dimana D merupakan matriks diagonal, L merupakan matriks segitiga bawah, dan U merupakan matriks segitiga atas. Lalu persamaan tersebut diubah menjadi : $$ Dx + (L + U)x = B $$ x = D^{-1}[b-(L +U)x] x = D^{-1}[b-(L +U)x] Jika ditulis dalam aturan iteratif, maka metode iterasi Jacobi dapat ditulis sebagai berikut : x^{(k)} = D^{-1}(b-(L+U)x^{k-1}) x^{(k)} = D^{-1}(b-(L+U)x^{k-1}) Dimana k merupakan banyaknya iterasi. Jika x^{(k)} x^{(k)} menyatakan hampiran ke \u2013 k k , maka x^{(0)} x^{(0)} adalah hampiran awal. x_{i}^{k} = \\frac{1}{a_{ii}}(b_i - \\sum _{j\\neq i}^{n}a_{ij}x_{j}^{(k-1)}),i = 1,2, ... , n; k = 1,2,3, ... ,n x_{i}^{k} = \\frac{1}{a_{ii}}(b_i - \\sum _{j\\neq i}^{n}a_{ij}x_{j}^{(k-1)}),i = 1,2, ... , n; k = 1,2,3, ... ,n Suatu matriks A berukuran n x n dikatakan dominan secara diagonal apabila : \\left | a_{ii} \\right | > \\left | a_{i,1} \\right | + ... + \\left | a_{i,i-1} \\right | + ... + \\left | a_{i,n} \\right | \\left | a_{ii} \\right | > \\left | a_{i,1} \\right | + ... + \\left | a_{i,i-1} \\right | + ... + \\left | a_{i,n} \\right | untuk i = 1,2,3, ... , n i = 1,2,3, ... , n Aplikasi Iterasi Jacobi \u00b6 Dengan rumus yang kita dapat diatas kita dapat mengimplementasikan sebuah aplikasi sebagai berikut. from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) dengan output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 10 Masukkan Nilai : 0 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 11 Masukkan Nilai : - 1 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 10 Masukkan Hasil : 6 Masukkan Hasil : 25 Masukkan Hasil : 11 A : array ([[ 10. , 0. , 2. ], [ - 1. , 11. , - 1. ], [ 2. , - 1. , 10. ]]) b : array ([ 6. , 25. , 11. ]) x : array ([ 0.34541985 , 2.41984733 , 1.27290076 ]) Metode Eliminasi Gauss \u00b6 Metode Eliminasi Gauss merupakan metode yang dikembangkan dari metode eliminasi, yaitu menghilangkan atau mengurangi jumlah variable sehingga dapat diperoleh nilai dari suatu variable bebas. Untuk menggunakan metode eliminasi Gauss ini, terlebih dahulu bentuk matrik diubah menjadi augmented matrik sebagai berikut : \\left[\\begin{array}{cccc|c} a_{11} & a_{12} & ... & a_{1n} & b_1 \\\\ a_{21} & a_{22} & ... & a_{2n} & b_2 \\\\ \\vdots & \\vdots & &\\vdots & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn} & b_m \\end{array} \\right] \\left[\\begin{array}{cccc|c} a_{11} & a_{12} & ... & a_{1n} & b_1 \\\\ a_{21} & a_{22} & ... & a_{2n} & b_2 \\\\ \\vdots & \\vdots & &\\vdots & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn} & b_m \\end{array} \\right] pada biagan kiri diubah menjadi matrik segitiga atas atau segitiga bawah dengan menggunakan OBE (Operasi Baris Elementer). \\begin{bmatrix} a_{11} & a_{12} & a_{13} & ... & a_{1n} & b_1\\\\ a_{21} & a_{22} & a_{23} & ... & a_{2n} & b_2\\\\ a_{31} & a_{32} & a_{33} & ... & a_{3n} & b_3\\\\ ... & ... & ... & ... & ... & ... \\\\ a_{m1} & a_{m2} & a_{m3} & ... & a_{mn} & b_n\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} c_{11} & c_{12} & c_{13} & ... & c_{1n} & d_1\\\\ 0 & c_{22} & a_{13} & ... & c_{2n} & d_2\\\\ 0 & 0 & c_{33} & ... & c_{3n} & d_3\\\\ ... & ... & ... & ... & ... & ...\\\\ 0 & 0 & 0 & ... & c_{mn} & c_n\\\\ \\end{bmatrix} \\begin{bmatrix} a_{11} & a_{12} & a_{13} & ... & a_{1n} & b_1\\\\ a_{21} & a_{22} & a_{23} & ... & a_{2n} & b_2\\\\ a_{31} & a_{32} & a_{33} & ... & a_{3n} & b_3\\\\ ... & ... & ... & ... & ... & ... \\\\ a_{m1} & a_{m2} & a_{m3} & ... & a_{mn} & b_n\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} c_{11} & c_{12} & c_{13} & ... & c_{1n} & d_1\\\\ 0 & c_{22} & a_{13} & ... & c_{2n} & d_2\\\\ 0 & 0 & c_{33} & ... & c_{3n} & d_3\\\\ ... & ... & ... & ... & ... & ...\\\\ 0 & 0 & 0 & ... & c_{mn} & c_n\\\\ \\end{bmatrix} Sehingga penyelesaian dapat diperoleh dengan: x_n = \\frac{d_n}{c_{mn}} x_n = \\frac{d_n}{c_{mn}} x_{n-1} = \\frac{1}{c_{n-1,n_1}}(-c_{n-1,n}x_n+d_{n-1}) x_{n-1} = \\frac{1}{c_{n-1,n_1}}(-c_{n-1,n}x_n+d_{n-1}) ...................... x_2 = \\frac{1}{c_{22}}(d_2-c_{23}x_3-x{24}x_4-...-c_{2n}x_n) x_2 = \\frac{1}{c_{22}}(d_2-c_{23}x_3-x{24}x_4-...-c_{2n}x_n) x_1 = \\frac{1}{c_{11}}(d_1-c_{12}x_2-x{13}x_3-...-c_{1n}x_n) x_1 = \\frac{1}{c_{11}}(d_1-c_{12}x_2-x{13}x_3-...-c_{1n}x_n) OBE pada baris ke- i+k dengan dasar baris ke i dapat dituliskan dengan : $$ a_{i+k,j} = a_{i+k,j}-c.a_{i,j} $$ dimana c adalah konstanta pengali yang diambil dari perbandingan nilai dari elemen a_{i,i} a_{i,i} dan a_{i+k,i} a_{i+k,i} Aplikasi Eliminasi Gauss \u00b6 Dari rumus diatas kita dapat mengimplementasikan sebuah program seperti berikut ini: import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Dengan Output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 10 Masukkan Nilai : 0 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 11 Masukkan Nilai : - 1 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 10 Masukkan Hasil : 6 Masukkan Hasil : 25 Masukkan Hasil : 11 Matrix A : [[ 10. 0. 2. ] [ 0. 11. - 0.8 ] [ 0. 0. 9.52727273 ]] Nilai X 3 = 1.2729007633587788 Nilai X 2 = 2.419847328244275 Nilai X 1 = 0.34541984732824427 Metode Gauss Seidel \u00b6 Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linier (SPL) berukuran besar dan proporsi koefisien nolnya besar. Dengan metode iterasi Gauss-Seidel hampiran pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas hampiran yang diperbolehkan. Pada metode iterasi Gauss-Seidel , nilai-nilai yang paling akhir dihitung digunakan di dalam semua perhitungan. Perbedaan Antara Jacobi dengan Gauss-Seidel : Jacobi : x_{i}^{k} = f(x_{1}^{k},x_{2}^{k}, ... ,x_{i-1}^{k},x_{i+1}^{k}, ... ,x_{n}^{k}) x_{i}^{k} = f(x_{1}^{k},x_{2}^{k}, ... ,x_{i-1}^{k},x_{i+1}^{k}, ... ,x_{n}^{k}) sedangkan Gauss-seidel : x_{i}^{k+1} = f(x_{1}^{k+1},x_{2}^{k+1}, ... ,x_{i-1}^{k+1},x_{i+1}^{k}, ... ,x_{n}^{k}) x_{i}^{k+1} = f(x_{1}^{k+1},x_{2}^{k+1}, ... ,x_{i-1}^{k+1},x_{i+1}^{k}, ... ,x_{n}^{k}) rumus untuk hampiran ke- k k pada metode iterasi Gauss-Seidel adalah sebagai berikut : x_{i}^{k} = \\frac{1}{a_{ii}}(b_{1} - \\sum_{j=1}^{i-1}a_{ij}x_{j}^{(k)} - \\sum_{j=i+1}^{n}a_{ij}x_{j}^{(k-1)}) x_{i}^{k} = \\frac{1}{a_{ii}}(b_{1} - \\sum_{j=1}^{i-1}a_{ij}x_{j}^{(k)} - \\sum_{j=i+1}^{n}a_{ij}x_{j}^{(k-1)}) dengan syarat a_{ii} \\neq 0 a_{ii} \\neq 0 dan k = 1, 2, ... k = 1, 2, ... Metode iterasi Gauss-Seidel dapat dinyatakan dalam bentuk matriks. Nyatakan matriks koefisien A sebagai A = D + (L + U) A = D + (L + U) , dengan L dan U berturut-turut adalah matriks segitiga bawah dan atas dengan diagonal nol dan D matriks diagonal. Rumus iterasi Gauss-Seidel dapat ditulis dalam bentuk : \\rightarrow x^{k} = D-1(b-Lx^{k}-Ux^{k-1}) \\rightarrow x^{k} = D-1(b-Lx^{k}-Ux^{k-1}) \\rightarrow (D+L)x^{k} = b-Ux^{k-1} \\rightarrow (D+L)x^{k} = b-Ux^{k-1} \\rightarrow x^{k} = (D+L)^{-1}(b-Ux^{k-1}) \\rightarrow x^{k} = (D+L)^{-1}(b-Ux^{k-1}) Yang menghasilkan : x^{(k)} = -(D+L)^{-1}Ux^{(k-1)}+(D+L)^{-1}b x^{(k)} = -(D+L)^{-1}Ux^{(k-1)}+(D+L)^{-1}b Metode iterasi Gauss-Seidel hampir sama dengan metode iterasi Jacobi. Perbedaannya hanya terletak pada penggunaan nilai elemen vektor x^{baru} x^{baru} yang langsung digunakan pada persamaan di bawahnya. Aplikasi Metode Gauss-Seidel \u00b6 Dari rumus yang kita dapatkan diatas kita dapat mengimplementasikan ke dalam program sebagai berikut : def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) #solusi print ( x ) Dengan Output : Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 10 Masukkan a1 , 2 : 0 Masukkan a1 , 3 : 2 Masukkan Hasil : 6 Masukkan a2 , 1 : - 1 Masukkan a2 , 2 : 11 Masukkan a2 , 3 : - 1 Masukkan Hasil : 25 Masukkan a3 , 1 : 2 Masukkan a3 , 2 : - 1 Masukkan a3 , 3 : 10 Masukkan Hasil : 11 [ 0 , 0 , 0 ] [ 0.6 , 2.3272727272727276 , 1.2127272727272729 ] [ 0.3574545454545454 , 2.415471074380165 , 1.2700561983471075 ] [ 0.3459887603305785 , 2.4196404507888802 , 1.2727662930127726 ] [ 0.34544674139744547 , 2.419837548582747 , 1.2728944065787855 ] [ 0.3454211186842429 , 2.419846865933003 , 1.2729004628564518 ] [ 0.34541990742870965 , 2.4198473063895602 , 1.272900749153214 ] [ 0.34541985016935717 , 2.419847327211143 , 1.2729007626872428 ] [ 0.34541984746255144 , 2.419847328195436 , 1.2729007633270333 ] [ 0.34541984733459336 , 2.419847328241966 , 1.272900763357278 ] [ 0.3454198473285444 , 2.4198473282441655 , 1.2729007633587075 ] [ 0.3454198473282585 , 2.4198473282442694 , 1.2729007633587752 ] [ 0.34541984732824493 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ]","title":"Tugas 3 (Jacobi , Eliminasi , Gaus Sidel)"},{"location":"Komnum/tugas3/#sistem-persamaan-linear-pendekatan-numerik","text":"Persamaan linear dalam n variabel x_1,x_2, . . . ,x_n x_1,x_2, . . . ,x_n adalah suatu persamaan yang bisa disajikan dalam bentuk : $$ a_{11}x_1+a_{12}x_2+ . . . +a_{1n}x_n = b_1 $$ a_{21}x_2+a_{22}x_2+ . . . +a_{2n}+x_n = b_2 a_{21}x_2+a_{22}x_2+ . . . +a_{2n}+x_n = b_2 \\vdots \\vdots $$ a_{m1}x_1+a_{m2}x_2+ . . . +a_{mn}x_n = b_m $$ dimana a_1,a_2, . . . , a_n a_1,a_2, . . . , a_n dan b b konstanta real. Variabel-variabel dalam suatu persamaan linear kadang disebut variabel bebas . Sebuah sistem m persamaan dalam n variabel dapat disingkat hanya menuliskan angka dalam bentuk segiempat. Dalam bentuk maktriks , SPL dapat ditulis dengan A**x* = b* , dimana : \\begin{bmatrix} a_{11} & a_{12} & ... & a_{1n}\\\\ a_{21} & a_{22} & ... & a_{2n}\\\\ \\vdots & \\vdots & & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn}\\\\ \\end{bmatrix}, x= \\begin{bmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{bmatrix}, b= \\begin{bmatrix} b_1\\\\ b_2\\\\ \\vdots\\\\ b_n \\end{bmatrix} \\begin{bmatrix} a_{11} & a_{12} & ... & a_{1n}\\\\ a_{21} & a_{22} & ... & a_{2n}\\\\ \\vdots & \\vdots & & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn}\\\\ \\end{bmatrix}, x= \\begin{bmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{bmatrix}, b= \\begin{bmatrix} b_1\\\\ b_2\\\\ \\vdots\\\\ b_n \\end{bmatrix}","title":"Sistem Persamaan Linear (Pendekatan Numerik)"},{"location":"Komnum/tugas3/#metode-iterasi-jacobi","text":"Metode iterasi Jacobi merupakan salah satu metode tak langsung, yang bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier yang proporsi koefisien nol nya besar. Jika diubah dari persamaan linier, maka akan menjadi : A_x = b A_x = b Kemudian diketahui bahwa A = D + (L + U), dimana D merupakan matriks diagonal, L merupakan matriks segitiga bawah, dan U merupakan matriks segitiga atas. Lalu persamaan tersebut diubah menjadi : $$ Dx + (L + U)x = B $$ x = D^{-1}[b-(L +U)x] x = D^{-1}[b-(L +U)x] Jika ditulis dalam aturan iteratif, maka metode iterasi Jacobi dapat ditulis sebagai berikut : x^{(k)} = D^{-1}(b-(L+U)x^{k-1}) x^{(k)} = D^{-1}(b-(L+U)x^{k-1}) Dimana k merupakan banyaknya iterasi. Jika x^{(k)} x^{(k)} menyatakan hampiran ke \u2013 k k , maka x^{(0)} x^{(0)} adalah hampiran awal. x_{i}^{k} = \\frac{1}{a_{ii}}(b_i - \\sum _{j\\neq i}^{n}a_{ij}x_{j}^{(k-1)}),i = 1,2, ... , n; k = 1,2,3, ... ,n x_{i}^{k} = \\frac{1}{a_{ii}}(b_i - \\sum _{j\\neq i}^{n}a_{ij}x_{j}^{(k-1)}),i = 1,2, ... , n; k = 1,2,3, ... ,n Suatu matriks A berukuran n x n dikatakan dominan secara diagonal apabila : \\left | a_{ii} \\right | > \\left | a_{i,1} \\right | + ... + \\left | a_{i,i-1} \\right | + ... + \\left | a_{i,n} \\right | \\left | a_{ii} \\right | > \\left | a_{i,1} \\right | + ... + \\left | a_{i,i-1} \\right | + ... + \\left | a_{i,n} \\right | untuk i = 1,2,3, ... , n i = 1,2,3, ... , n","title":"Metode Iterasi Jacobi"},{"location":"Komnum/tugas3/#aplikasi-iterasi-jacobi","text":"Dengan rumus yang kita dapat diatas kita dapat mengimplementasikan sebuah aplikasi sebagai berikut. from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) dengan output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 10 Masukkan Nilai : 0 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 11 Masukkan Nilai : - 1 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 10 Masukkan Hasil : 6 Masukkan Hasil : 25 Masukkan Hasil : 11 A : array ([[ 10. , 0. , 2. ], [ - 1. , 11. , - 1. ], [ 2. , - 1. , 10. ]]) b : array ([ 6. , 25. , 11. ]) x : array ([ 0.34541985 , 2.41984733 , 1.27290076 ])","title":"Aplikasi Iterasi Jacobi"},{"location":"Komnum/tugas3/#metode-eliminasi-gauss","text":"Metode Eliminasi Gauss merupakan metode yang dikembangkan dari metode eliminasi, yaitu menghilangkan atau mengurangi jumlah variable sehingga dapat diperoleh nilai dari suatu variable bebas. Untuk menggunakan metode eliminasi Gauss ini, terlebih dahulu bentuk matrik diubah menjadi augmented matrik sebagai berikut : \\left[\\begin{array}{cccc|c} a_{11} & a_{12} & ... & a_{1n} & b_1 \\\\ a_{21} & a_{22} & ... & a_{2n} & b_2 \\\\ \\vdots & \\vdots & &\\vdots & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn} & b_m \\end{array} \\right] \\left[\\begin{array}{cccc|c} a_{11} & a_{12} & ... & a_{1n} & b_1 \\\\ a_{21} & a_{22} & ... & a_{2n} & b_2 \\\\ \\vdots & \\vdots & &\\vdots & \\vdots \\\\ a_{m1} & a_{m2} & ... & a_{mn} & b_m \\end{array} \\right] pada biagan kiri diubah menjadi matrik segitiga atas atau segitiga bawah dengan menggunakan OBE (Operasi Baris Elementer). \\begin{bmatrix} a_{11} & a_{12} & a_{13} & ... & a_{1n} & b_1\\\\ a_{21} & a_{22} & a_{23} & ... & a_{2n} & b_2\\\\ a_{31} & a_{32} & a_{33} & ... & a_{3n} & b_3\\\\ ... & ... & ... & ... & ... & ... \\\\ a_{m1} & a_{m2} & a_{m3} & ... & a_{mn} & b_n\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} c_{11} & c_{12} & c_{13} & ... & c_{1n} & d_1\\\\ 0 & c_{22} & a_{13} & ... & c_{2n} & d_2\\\\ 0 & 0 & c_{33} & ... & c_{3n} & d_3\\\\ ... & ... & ... & ... & ... & ...\\\\ 0 & 0 & 0 & ... & c_{mn} & c_n\\\\ \\end{bmatrix} \\begin{bmatrix} a_{11} & a_{12} & a_{13} & ... & a_{1n} & b_1\\\\ a_{21} & a_{22} & a_{23} & ... & a_{2n} & b_2\\\\ a_{31} & a_{32} & a_{33} & ... & a_{3n} & b_3\\\\ ... & ... & ... & ... & ... & ... \\\\ a_{m1} & a_{m2} & a_{m3} & ... & a_{mn} & b_n\\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} c_{11} & c_{12} & c_{13} & ... & c_{1n} & d_1\\\\ 0 & c_{22} & a_{13} & ... & c_{2n} & d_2\\\\ 0 & 0 & c_{33} & ... & c_{3n} & d_3\\\\ ... & ... & ... & ... & ... & ...\\\\ 0 & 0 & 0 & ... & c_{mn} & c_n\\\\ \\end{bmatrix} Sehingga penyelesaian dapat diperoleh dengan: x_n = \\frac{d_n}{c_{mn}} x_n = \\frac{d_n}{c_{mn}} x_{n-1} = \\frac{1}{c_{n-1,n_1}}(-c_{n-1,n}x_n+d_{n-1}) x_{n-1} = \\frac{1}{c_{n-1,n_1}}(-c_{n-1,n}x_n+d_{n-1}) ...................... x_2 = \\frac{1}{c_{22}}(d_2-c_{23}x_3-x{24}x_4-...-c_{2n}x_n) x_2 = \\frac{1}{c_{22}}(d_2-c_{23}x_3-x{24}x_4-...-c_{2n}x_n) x_1 = \\frac{1}{c_{11}}(d_1-c_{12}x_2-x{13}x_3-...-c_{1n}x_n) x_1 = \\frac{1}{c_{11}}(d_1-c_{12}x_2-x{13}x_3-...-c_{1n}x_n) OBE pada baris ke- i+k dengan dasar baris ke i dapat dituliskan dengan : $$ a_{i+k,j} = a_{i+k,j}-c.a_{i,j} $$ dimana c adalah konstanta pengali yang diambil dari perbandingan nilai dari elemen a_{i,i} a_{i,i} dan a_{i+k,i} a_{i+k,i}","title":"Metode Eliminasi Gauss"},{"location":"Komnum/tugas3/#aplikasi-eliminasi-gauss","text":"Dari rumus diatas kita dapat mengimplementasikan sebuah program seperti berikut ini: import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Dengan Output : Masukkan ukuran Matrix : 3 Masukkan Nilai : 10 Masukkan Nilai : 0 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 11 Masukkan Nilai : - 1 Masukkan Nilai : 2 Masukkan Nilai : - 1 Masukkan Nilai : 10 Masukkan Hasil : 6 Masukkan Hasil : 25 Masukkan Hasil : 11 Matrix A : [[ 10. 0. 2. ] [ 0. 11. - 0.8 ] [ 0. 0. 9.52727273 ]] Nilai X 3 = 1.2729007633587788 Nilai X 2 = 2.419847328244275 Nilai X 1 = 0.34541984732824427","title":"Aplikasi Eliminasi Gauss"},{"location":"Komnum/tugas3/#metode-gauss-seidel","text":"Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linier (SPL) berukuran besar dan proporsi koefisien nolnya besar. Dengan metode iterasi Gauss-Seidel hampiran pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas hampiran yang diperbolehkan. Pada metode iterasi Gauss-Seidel , nilai-nilai yang paling akhir dihitung digunakan di dalam semua perhitungan. Perbedaan Antara Jacobi dengan Gauss-Seidel : Jacobi : x_{i}^{k} = f(x_{1}^{k},x_{2}^{k}, ... ,x_{i-1}^{k},x_{i+1}^{k}, ... ,x_{n}^{k}) x_{i}^{k} = f(x_{1}^{k},x_{2}^{k}, ... ,x_{i-1}^{k},x_{i+1}^{k}, ... ,x_{n}^{k}) sedangkan Gauss-seidel : x_{i}^{k+1} = f(x_{1}^{k+1},x_{2}^{k+1}, ... ,x_{i-1}^{k+1},x_{i+1}^{k}, ... ,x_{n}^{k}) x_{i}^{k+1} = f(x_{1}^{k+1},x_{2}^{k+1}, ... ,x_{i-1}^{k+1},x_{i+1}^{k}, ... ,x_{n}^{k}) rumus untuk hampiran ke- k k pada metode iterasi Gauss-Seidel adalah sebagai berikut : x_{i}^{k} = \\frac{1}{a_{ii}}(b_{1} - \\sum_{j=1}^{i-1}a_{ij}x_{j}^{(k)} - \\sum_{j=i+1}^{n}a_{ij}x_{j}^{(k-1)}) x_{i}^{k} = \\frac{1}{a_{ii}}(b_{1} - \\sum_{j=1}^{i-1}a_{ij}x_{j}^{(k)} - \\sum_{j=i+1}^{n}a_{ij}x_{j}^{(k-1)}) dengan syarat a_{ii} \\neq 0 a_{ii} \\neq 0 dan k = 1, 2, ... k = 1, 2, ... Metode iterasi Gauss-Seidel dapat dinyatakan dalam bentuk matriks. Nyatakan matriks koefisien A sebagai A = D + (L + U) A = D + (L + U) , dengan L dan U berturut-turut adalah matriks segitiga bawah dan atas dengan diagonal nol dan D matriks diagonal. Rumus iterasi Gauss-Seidel dapat ditulis dalam bentuk : \\rightarrow x^{k} = D-1(b-Lx^{k}-Ux^{k-1}) \\rightarrow x^{k} = D-1(b-Lx^{k}-Ux^{k-1}) \\rightarrow (D+L)x^{k} = b-Ux^{k-1} \\rightarrow (D+L)x^{k} = b-Ux^{k-1} \\rightarrow x^{k} = (D+L)^{-1}(b-Ux^{k-1}) \\rightarrow x^{k} = (D+L)^{-1}(b-Ux^{k-1}) Yang menghasilkan : x^{(k)} = -(D+L)^{-1}Ux^{(k-1)}+(D+L)^{-1}b x^{(k)} = -(D+L)^{-1}Ux^{(k-1)}+(D+L)^{-1}b Metode iterasi Gauss-Seidel hampir sama dengan metode iterasi Jacobi. Perbedaannya hanya terletak pada penggunaan nilai elemen vektor x^{baru} x^{baru} yang langsung digunakan pada persamaan di bawahnya.","title":"Metode Gauss Seidel"},{"location":"Komnum/tugas3/#aplikasi-metode-gauss-seidel","text":"Dari rumus yang kita dapatkan diatas kita dapat mengimplementasikan ke dalam program sebagai berikut : def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) #solusi print ( x ) Dengan Output : Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 10 Masukkan a1 , 2 : 0 Masukkan a1 , 3 : 2 Masukkan Hasil : 6 Masukkan a2 , 1 : - 1 Masukkan a2 , 2 : 11 Masukkan a2 , 3 : - 1 Masukkan Hasil : 25 Masukkan a3 , 1 : 2 Masukkan a3 , 2 : - 1 Masukkan a3 , 3 : 10 Masukkan Hasil : 11 [ 0 , 0 , 0 ] [ 0.6 , 2.3272727272727276 , 1.2127272727272729 ] [ 0.3574545454545454 , 2.415471074380165 , 1.2700561983471075 ] [ 0.3459887603305785 , 2.4196404507888802 , 1.2727662930127726 ] [ 0.34544674139744547 , 2.419837548582747 , 1.2728944065787855 ] [ 0.3454211186842429 , 2.419846865933003 , 1.2729004628564518 ] [ 0.34541990742870965 , 2.4198473063895602 , 1.272900749153214 ] [ 0.34541985016935717 , 2.419847327211143 , 1.2729007626872428 ] [ 0.34541984746255144 , 2.419847328195436 , 1.2729007633270333 ] [ 0.34541984733459336 , 2.419847328241966 , 1.272900763357278 ] [ 0.3454198473285444 , 2.4198473282441655 , 1.2729007633587075 ] [ 0.3454198473282585 , 2.4198473282442694 , 1.2729007633587752 ] [ 0.34541984732824493 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ] [ 0.34541984732824427 , 2.4198473282442747 , 1.2729007633587786 ]","title":"Aplikasi Metode Gauss-Seidel"},{"location":"Komnum/tugas4/","text":"Integral Numerik \u00b6 Integral numerik juga dinamakan quadrature , Quadrature pada prinsipnya adalah konsep yang sangat mudah yaitu bagaimana mengevaluasi integral suatu fungsi : I = \\int_{a}^{b} f(x)dx I = \\int_{a}^{b} f(x)dx Dipandang dari sudut persamaan diferensial maka mencari nilai integral I adalah sama dengan menyelesaikan persamaan diferensial : \\frac{dy}{dx} = f(x) \\frac{dy}{dx} = f(x) Dengan syarat batas f(x)=0 f(x)=0 Metode Recursive Trapezoid \u00b6 Metode Recursive Trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann. Selanjutnya, menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus : \\int_{a}^{b} f(x)dx = F(b) - F(a) \\int_{a}^{b} f(x)dx = F(b) - F(a) Dengan F(x) F(x) adalah antiderivatif f(x) f(x) yakni F'(x) = f(x) F'(x) = f(x) . Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Misalkan f f adalah suatu fungsi yang terdefinisi pada \\left [ a,b \\right ] \\left [ a,b \\right ] . Misalkan a = x_0 < x_1 < x_2 < ... < x_n a = x_0 < x_1 < x_2 < ... < x_n suatu partisi sedemikian sehingga x_k = x_n + kh x_k = x_n + kh dengan h = (b - a)/n h = (b - a)/n untuk k = 0,1,2,3, .., n k = 0,1,2,3, .., n . Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval) : T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n \u200b = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) \u200b = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k Sekarang, jika lebar setiap subinterval diperkecil separuhnya, maka dengan : T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan : T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} dan f_i = f(a+i\\frac{h}{2^{k+1}}) f_i = f(a+i\\frac{h}{2^{k+1}}) Dalam menghitung hampiran \\int_{a}^{b} f(x)dx \\int_{a}^{b} f(x)dx dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut : h = b - 1 h = b - 1 T_0 = \\frac{h}{2}(f(a)+f(b)) T_0 = \\frac{h}{2}(f(a)+f(b)) T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) Aplikasi Metode Recursive Trapezoid \u00b6 Dengan rumus diatas kita dapat membuat aplikasi dengan cara mengimplementasikannya sebagai berikut: def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) print ( \"iterasi\" , \"n\" , \"trapesium\" ) for iterasi in range ( 1 , 16 , 1 ): n = 2 * iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) print ( iterasi , n , hasil ) dengan output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 1 Masukkan batas atas integral : 5 ( 'iterasi' , 'n' , 'trapesium' ) ( 1 , 2 , 1.1666666666666667 ) ( 2 , 4 , 1.1166666666666665 ) ( 3 , 6 , 1.1067460317460316 ) ( 4 , 8 , 1.1032106782106783 ) ( 5 , 10 , 1.1015623265623267 ) ( 6 , 12 , 1.1006636337518692 ) ( 7 , 14 , 1.1001206095246345 ) ( 8 , 16 , 1.0997677015630307 ) ( 9 , 18 , 1.0995255363208654 ) ( 10 , 20 , 1.0993522102854703 ) ( 11 , 22 , 1.0992239111652358 ) ( 12 , 24 , 1.0991262963617388 ) ( 13 , 26 , 1.0990503094436468 ) ( 14 , 28 , 1.098990003895536 ) ( 15 , 30 , 1.0989413445445515 )","title":"Tugas 4 (Integrasi Numerik Menggunakan Recursive Trapezoid)"},{"location":"Komnum/tugas4/#integral-numerik","text":"Integral numerik juga dinamakan quadrature , Quadrature pada prinsipnya adalah konsep yang sangat mudah yaitu bagaimana mengevaluasi integral suatu fungsi : I = \\int_{a}^{b} f(x)dx I = \\int_{a}^{b} f(x)dx Dipandang dari sudut persamaan diferensial maka mencari nilai integral I adalah sama dengan menyelesaikan persamaan diferensial : \\frac{dy}{dx} = f(x) \\frac{dy}{dx} = f(x) Dengan syarat batas f(x)=0 f(x)=0","title":"Integral Numerik"},{"location":"Komnum/tugas4/#metode-recursive-trapezoid","text":"Metode Recursive Trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann. Selanjutnya, menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus : \\int_{a}^{b} f(x)dx = F(b) - F(a) \\int_{a}^{b} f(x)dx = F(b) - F(a) Dengan F(x) F(x) adalah antiderivatif f(x) f(x) yakni F'(x) = f(x) F'(x) = f(x) . Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Misalkan f f adalah suatu fungsi yang terdefinisi pada \\left [ a,b \\right ] \\left [ a,b \\right ] . Misalkan a = x_0 < x_1 < x_2 < ... < x_n a = x_0 < x_1 < x_2 < ... < x_n suatu partisi sedemikian sehingga x_k = x_n + kh x_k = x_n + kh dengan h = (b - a)/n h = (b - a)/n untuk k = 0,1,2,3, .., n k = 0,1,2,3, .., n . Perhatikan aturan trapesium untuk fungsi f f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval) : T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n T_n(f,h) = \\frac{h}{2}(f_0 + 2f_1 + 2f_2 + ... + 2f_{n-1}) + f_n \u200b = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) = \\frac{h}{2}(f_0 +f_n) +h(f_1 + f_2 + ... + f_{n-1}) \u200b = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k = \\frac{h}{2}(f_0 +f_n) +h\\sum_{k=1}^{n-1}f_k Sekarang, jika lebar setiap subinterval diperkecil separuhnya, maka dengan : T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) T_0 = T_1(f,h) = \\frac{h}{2}(f(a)+f(b)) dan T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... T_k = T_{2^k}(f, \\frac{h}{2^k}), k = 1,2,3, ... Barisan aturan trapesium tersebut memenuhi hubungan : T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} T_k + 1 = \\frac{T_k}{2} + \\frac{h}{2^{k+1}}\\sum{j=i}^{2^k}f{2j-i} dan f_i = f(a+i\\frac{h}{2^{k+1}}) f_i = f(a+i\\frac{h}{2^{k+1}}) Dalam menghitung hampiran \\int_{a}^{b} f(x)dx \\int_{a}^{b} f(x)dx dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut : h = b - 1 h = b - 1 T_0 = \\frac{h}{2}(f(a)+f(b)) T_0 = \\frac{h}{2}(f(a)+f(b)) T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_1 = \\frac{T_0}{2} + \\frac{h}{2}f_1 T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_2 = \\frac{T_1}{2} + \\frac{h}{4}(f_1 + f_3) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5) T_3 = \\frac{T_2}{2} + \\frac{h}{8}(f_1 + f_3 + f_5)","title":"Metode Recursive Trapezoid"},{"location":"Komnum/tugas4/#aplikasi-metode-recursive-trapezoid","text":"Dengan rumus diatas kita dapat membuat aplikasi dengan cara mengimplementasikannya sebagai berikut: def fungsi ( x ) : y = 1 / ( 1 + x ) return y print ( \"f(x) = 1/(1+x)\" ) a = float ( input ( \"Masukkan batas bawah integral : \" )) b = float ( input ( \"Masukkan batas atas integral : \" )) print ( \"iterasi\" , \"n\" , \"trapesium\" ) for iterasi in range ( 1 , 16 , 1 ): n = 2 * iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) hasil = ( h ) * (( fungsi ( a ) + ( 2 * y ) + fungsi ( b )) / 2 ) print ( iterasi , n , hasil ) dengan output : f ( x ) = 1 / ( 1 + x ) Masukkan batas bawah integral : 1 Masukkan batas atas integral : 5 ( 'iterasi' , 'n' , 'trapesium' ) ( 1 , 2 , 1.1666666666666667 ) ( 2 , 4 , 1.1166666666666665 ) ( 3 , 6 , 1.1067460317460316 ) ( 4 , 8 , 1.1032106782106783 ) ( 5 , 10 , 1.1015623265623267 ) ( 6 , 12 , 1.1006636337518692 ) ( 7 , 14 , 1.1001206095246345 ) ( 8 , 16 , 1.0997677015630307 ) ( 9 , 18 , 1.0995255363208654 ) ( 10 , 20 , 1.0993522102854703 ) ( 11 , 22 , 1.0992239111652358 ) ( 12 , 24 , 1.0991262963617388 ) ( 13 , 26 , 1.0990503094436468 ) ( 14 , 28 , 1.098990003895536 ) ( 15 , 30 , 1.0989413445445515 )","title":"Aplikasi Metode Recursive Trapezoid"},{"location":"Komnum/tugas5/","text":"Richardson Extrapolation \u00b6 Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Dalam rumus : \\frac{f(x+h)-f(x-h)}{2h} \\frac{f(x+h)-f(x-h)}{2h} untuk nilai h h yang sangat kecil, dua fungsi evaluasi f (x + h) f (x + h) dan f (x - h) f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e e dengan perkiraan a(h) a(h) . Dalam hal ini, e e adalah turunan dari f '(x) f '(x) dan perkiraannya adalah (h) = \\frac{f(x+h)-f(x-h)}{2h} (h) = \\frac{f(x+h)-f(x-h)}{2h} . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : $$ e = a(h) + Kh n+o(h n) $$ Apabila menggunakan \\frac{h}{2} \\frac{h}{2} : $$ e = a(\\frac{h}{2})+K(\\frac{h}{2})+o((\\frac{h}{2})n) $$ = a(\\frac{h}{2})+\\frac{K}{2n}h^n+o(h^n) = a(\\frac{h}{2})+\\frac{K}{2n}h^n+o(h^n) Mengalikan kedua ekspresi ini dengan 2n 2n dan mengurangi hasil persamaan pertama 2n^e - e = 2na(\\frac{h}{2})-a(h)+\\frac{K}{2n}h^n - K h^n+o(h^n) 2n^e - e = 2na(\\frac{h}{2})-a(h)+\\frac{K}{2n}h^n - K h^n+o(h^n) Perhatikan bahwa istilah h^2 h^2 dibatalkan dan kita dibiarkan dengan $$ (2n-1)e = 2na(\\frac{h}{2})-a(h)-o(h^n) $$ Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : $$ K1 = \\frac{-1}{6}f(3)(x)h^2 , etc $$ Contoh Program \u00b6 from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f(x) = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'Hasil Diferensiasi Numerik= ' + ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) Hasil Running \u00b6 f ( x ) = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 Hasil Diferensiasi Numerik = - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050","title":"Tugas 5 (Richardson Extrapolation)"},{"location":"Komnum/tugas5/#richardson-extrapolation","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Dalam rumus : \\frac{f(x+h)-f(x-h)}{2h} \\frac{f(x+h)-f(x-h)}{2h} untuk nilai h h yang sangat kecil, dua fungsi evaluasi f (x + h) f (x + h) dan f (x - h) f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e e dengan perkiraan a(h) a(h) . Dalam hal ini, e e adalah turunan dari f '(x) f '(x) dan perkiraannya adalah (h) = \\frac{f(x+h)-f(x-h)}{2h} (h) = \\frac{f(x+h)-f(x-h)}{2h} . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : $$ e = a(h) + Kh n+o(h n) $$ Apabila menggunakan \\frac{h}{2} \\frac{h}{2} : $$ e = a(\\frac{h}{2})+K(\\frac{h}{2})+o((\\frac{h}{2})n) $$ = a(\\frac{h}{2})+\\frac{K}{2n}h^n+o(h^n) = a(\\frac{h}{2})+\\frac{K}{2n}h^n+o(h^n) Mengalikan kedua ekspresi ini dengan 2n 2n dan mengurangi hasil persamaan pertama 2n^e - e = 2na(\\frac{h}{2})-a(h)+\\frac{K}{2n}h^n - K h^n+o(h^n) 2n^e - e = 2na(\\frac{h}{2})-a(h)+\\frac{K}{2n}h^n - K h^n+o(h^n) Perhatikan bahwa istilah h^2 h^2 dibatalkan dan kita dibiarkan dengan $$ (2n-1)e = 2na(\\frac{h}{2})-a(h)-o(h^n) $$ Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : $$ K1 = \\frac{-1}{6}f(3)(x)h^2 , etc $$","title":"Richardson Extrapolation"},{"location":"Komnum/tugas5/#contoh-program","text":"from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f(x) = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'Hasil Diferensiasi Numerik= ' + ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 ))","title":"Contoh Program"},{"location":"Komnum/tugas5/#hasil-running","text":"f ( x ) = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 Hasil Diferensiasi Numerik = - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050","title":"Hasil Running"}]}